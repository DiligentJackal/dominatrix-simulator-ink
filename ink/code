


=== exit ===
// {isWeb(): -> table_of_contents}

{
    - deviation == hand_signals:
        /scene none
        -> headmistress_hub
    - deviation == exhibitionism:
        /scene none
        -> headmistress_hub
    - deviation == puppyplay:
        /scene none
        -> yuki_hub
    - deviation == tutorial:
        -> pause(3) ->
        -> entry_hub
    - deviation == demo:
        -> pause(3) ->
        -> demo_end
}

{inTutorial:
    -> entry_hub
- else:
    {shuffle:
        - -> goddess_monitoring
        - -> entry_hub
        - -> entry_hub
        - -> entry_hub
        - -> entry_hub
        - -> entry_hub
    }
}

=== pause(seconds) ===
+ [wait:{seconds}] 
- ->->

=== demo_end ===
/scene EntryDark.EndScreen
/music entry
/ambient rain
/log Cherry popped! Setting variable which should restart at shortcuts.
~ cherryPopped = true
~ hasRestarted = true

+ [restart]
    ~ inTutorial = true
    ~ tutorial_step = at_game_intro
    ~ hasRestarted = true
    -> game_intro

=== unlock_shortcuts ===
~ goddess_shortcut = true
~ yuki_shortcut = true
~ nega_shortcut = true
~ hm_shortcut = true
~ goddess_angry_shortcut = true
~ hm_bonus_shortcut = true
~ goddess_pleased_shortcut = true
->->

=== unlock_all ===
~ goddess_hub_status = unlocked
~ inTutorial = false
-> unlock_shortcuts ->
->->


// Fallback for isWeb() external function
=== function isWeb() ===
~ return web


// Fallback for isDebug() external function
=== function isDebug() ===
~ return debug


=== select_gender_check ===
{hasChosen(): ->->}
-> select_gender ->->

=== select_gender ===
/scene entrydark.genderchoice
/ambient rain
/music entry

- (options)

+ [character-choice:male]
    ~ setGender("m")
    /notify text="<i>You now appear masculine.</i>" delay=10
    -> options

+ [character-choice:female]
    ~ setGender("f")
    /notify text="<i>You now appear feminine.</i>" delay=10
    -> options

+ {hasChosen()} [move]

- ->->


=== function hasChosen() ===
~ return player_name != "none"


=== function setGender(gender) ===
{
    - gender == "m":
        ~ isBoy = true
        ~ isGirl = false
        ~ hasPenis = true
        ~ player_name = "boy"
    - gender == "f":
        ~ isBoy = false
        ~ isGirl = true
        ~ hasPenis = false
        ~ player_name = "girl"
    - gender == "p":
        ~ isBoy = false
        ~ isGirl = false
        ~ hasPenis = true
        ~ player_name = "pet"
}

~ return


=== function addPunishment() ===
{ punishments >= 10:
    /logError Can't add a punishment. Already at 10.
    ~ return false
}

~ punishments++
~ reward_just_removed = false
~ punishment_just_removed = false
~ changeRegard(-1)

{isWeb():
    <b>Punishment Added</b>
	<i>{getSummaryText()}</i>
- else:
    /log Punishment Added: {getSummaryText()}
}

~ return true


=== function removePunishment() ===
{ punishments <= 0:
    /logError Can't remove punishment. Already at 0.
    ~ return false
}

~ punishments--
~ reward_just_removed = true
~ punishment_just_removed = false

{isWeb():
    <b>Punishment Removed</b>
	<i>{getSummaryText()}</i>
- else:
    /log Punishment Removed: {getSummaryText()}
}

~ return true


=== function removeBigPunishment() ===
{ punishments < 10:
    /logError Can't remove 10 punishments. Not at 10.
    ~ return false
}

~ punishments -= 10
~ reward_just_removed = false
~ punishment_just_removed = false

{isWeb():
    <b>Punishment x10 Removed</b>
	<i>{getSummaryText()}</i>
- else:
    /log Punishment x10 Removed: {getSummaryText()}
}

~ return true


=== function addReward() ===
{ rewards >= 10:
    /logError Can't add a reward. Already at 10.
    ~ return false
}

~ rewards++
~ reward_just_removed = false
~ punishment_just_removed = false
~ changeRegard(1)

{isWeb():
    <b>Reward Added</b>
	<i>{getSummaryText()}</i>
- else:
    /log Reward Added: {getSummaryText()}
}

~ return


=== function removeReward() ===
{ rewards <= 0:
    /logError Can't remove a reward. Already at 0.
    ~ return false
}

~ rewards--
~ punishment_just_removed = true
~ reward_just_removed = false

{isWeb():
    <b>Reward Removed</b>
	<i>{getSummaryText()}</i>
- else:
    /log Reward Removed: {getSummaryText()}
}

~ return true


=== function removeBigReward() ===
{ rewards < 10:
    /logError Can't remove 10 rewards. Not at 10.
    ~ return false
}

~ rewards -= 10
~ punishment_just_removed = true
~ reward_just_removed = false

{isWeb():
    <b>Reward x10 Removed</b>
	<i>{getSummaryText()}</i>
- else:
    /log Reward x10 Removed: {getSummaryText()}
}

~ return true


=== function increaseRegard() ===
~ changeRegard(1)

=== function decreaseRegard() ===
~ changeRegard(-1)

=== function changeRegard(amount) ===
~ changeRegardTo(current_mistress, amount)

=== function increaseRegardTo(mistress) ===
~ changeRegardTo(mistress, 1)

=== function decreaseRegardTo(mistress) ===
~ changeRegardTo(mistress, -1)

=== function changeRegardTo(mistress, amount) ===
{
    - mistress == Goddess:
        ~ goddess_regard += amount
    - mistress == Headmistress:
        ~ headmistress_regard += amount
    - mistress == Nega:
        ~ nega_regard += amount
    - mistress == Yuki:
        ~ yuki_regard += amount
    - else:
        /logError Can't change {mistress}'s regard.
}


// Fallback for getNegaDie1/2/3() external function
=== function getNegaDie1() ===
~ return getNegaDie()


=== function getNegaDie2() ===
~ return getNegaDie()


=== function getNegaDie3() ===
~ return getNegaDie()


=== function getNegaDie() ===
~ temp roll = 0

{shuffle:
    - ~roll = -1
    - ~roll = -1
    - ~roll = -1
    - ~roll = 0
    - ~roll = 1
    - ~roll = 1
}

~ return roll


=== function rollToText(roll) ===
{
    - roll == -1: Skull
    - roll == 0: Blank
    - roll == 1: Cup
}


=== function setDeviation(d) ===

// Set the deviation.
~ deviation = d

// Set inTutorial to true only for tutorial, demo, and full game.
~ inTutorial = deviation == demo || deviation == tutorial || deviation == full_game

~ return


=== function setHub(mistress) ===
~ setScene(hub_scene, mistress)


=== function setScene(type, mistress) ===
~ current_mistress = mistress
~ scene_type = type
~ checked_if_interested = false
~ resetObeyed()

~ temp mistressName = "{mistress}"

{ mistress == None:
    - ~ mistressName = "Entry"
}

{isWeb():
    <b>{mistressName} {type}</b>
	<i>{getSummaryText()}</i>
- else:
    /log {mistressName} {type} / {getSummaryText()}
}

=== function getSummaryText() ===
~ temp regardText = ""
~ temp deviationText = "/ Deviation: {deviation}"

// Set regard text if with a mistress.
{
    - current_mistress == Goddess:
        ~ regardText = "/ {current_mistress} Regard: {goddess_regard}"
    - current_mistress == Headmistress:
        ~ regardText = "/ {current_mistress} Regard: {headmistress_regard}"
    - current_mistress == Nega:
        ~ regardText = "/ {current_mistress} Regard: {nega_regard}"
    - current_mistress == Yuki:
        ~ regardText = "/ {current_mistress} Regard: {yuki_regard}"
}

// Set optional deviation-specific text
{deviation == tutorial:
    ~ deviationText = "/ Deviation: tutorial @ {tutorial_step}"
}

~ return  "Punishments: {punishments} / Rewards: {rewards} {regardText} {deviationText}"

=== function obeyed() ===
{isWeb():
	<i>Checking Obeyed: Obey = {obey} / Disobey = {disobey} / Obeying = {obey - disobey > 0:true|false}</i>
- else:
    /log Checking Obeyed: Obey = {obey} / Disobey = {disobey} / Obeying = {obey - disobey > 0:true|false}
}

~ return obey - disobey > 0

=== function resetObeyed() ===
~ obey = 0
~ disobey = 0

=== function addObey() ===
~ obey++

{isWeb():
	<i>Obey Increased: Obey = {obey} / Disobey = {disobey} / Obeying = {obey - disobey > 0:true|false}</i>
- else:
    /log Obey Increased: Obey = {obey} / Disobey = {disobey} / Obeying = {obey - disobey > 0:true|false}
}

=== function addDisobey() ===
~ disobey++

{isWeb():
	<i>Disobey Increased: Obey = {obey} / Disobey = {disobey} / Obeying = {obey - disobey > 0:true|false}</i>
- else:
    /log Disobey Increased: Obey = {obey} / Disobey = {disobey} / Obeying = {obey - disobey > 0:true|false}
}



=== RandomCommentLoop(-> commentTunnel, minTimes, maxTimes, minWait, maxWait)
~ temp count = 0
~ temp max = RANDOM(minTimes, maxTimes)
/log Comments looping {max} times.
- (repeat)

-> commentTunnel ->
+ [wait {RANDOM(minWait, maxWait)}]
~ count++
{ count < max: -> repeat | ->-> }

=== RandomCommentLoopWithNo(-> commentTunnel, -> noTunnel, minTimes, maxTimes, minWait, maxWait)
~ temp count = 0
~ temp max = RANDOM(minTimes, maxTimes)
/log Comments looping {max} times.
- (repeat)

-> commentTunnel ->
+ [wait {RANDOM(minWait, maxWait)}]
+ [no] -> noTunnel
- ~ count++
{ count < max: -> repeat | ->-> }

=== RandomCommentLoopWithYes(-> commentTunnel, -> yesTunnel, minTimes, maxTimes, minWait, maxWait)
~ temp count = 0
~ temp max = RANDOM(minTimes, maxTimes)
/log Comments looping {max} times.
- (repeat)

-> commentTunnel ->
+ [wait {RANDOM(minWait, maxWait)}]
+ [yes] -> yesTunnel
- ~ count++
{ count < max: -> repeat | ->-> }
